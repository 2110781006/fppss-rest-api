/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (5.0.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.api;

import io.swagger.annotations.*;
import org.openapitools.model.TimeValueObject;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.context.request.NativeWebRequest;

import javax.validation.Valid;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2022-10-01T11:49:21.249468300+02:00[Europe/Vienna]")
@Validated
@Api(value = "values", description = "the values API")
public interface ValuesApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    /**
     * POST /values/consumption/day
     * save consumption day values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionDay", notes = "save consumption day values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/consumption/day",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesConsumptionDay(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.day, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/consumption/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of day values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionDayLastTimeStamp", notes = "get last timestamp of day values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/consumption/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesConsumptionDayLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.day, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/consumption/hour
     * save consumption hour values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionHour", notes = "save consumption hour values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/consumption/hour",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesConsumptionHour(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.hour, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/consumption/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of hour values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionHourLastTimeStamp", notes = "get last timestamp of hour values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/consumption/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesConsumptionHourLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.hour, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/consumption/month
     * save consumption month values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionMonth", notes = "save consumption month values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/consumption/month",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesConsumptionMonth(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.month, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/consumption/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of month values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionMonthLastTimeStamp", notes = "get last timestamp of month values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/consumption/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesConsumptionMonthLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.month, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/consumption/year
     * save consumption year values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionYear", notes = "save consumption year values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/consumption/year",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesConsumptionYear(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.year, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/consumption/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of year values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionYearLastTimeStamp", notes = "get last timestamp of year values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/consumption/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesConsumptionYearLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.year, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/feedin/day
     * save feedin day values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinDay", notes = "save feedin day values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/feedin/day",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesFeedinDay(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.day, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/feedin/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of day values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinDayLastTimeStamp", notes = "get last timestamp of day values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/feedin/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesFeedinDayLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.day, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/feedin/hour
     * save feedin hour values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinHour", notes = "save feedin hour values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/feedin/hour",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesFeedinHour(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.day, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/feedin/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of hour values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinHourLastTimeStamp", notes = "get last timestamp of hour values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/feedin/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesFeedinHourLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.hour, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/feedin/month
     * save feedin month values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinMonth", notes = "save feedin month values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/feedin/month",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesFeedinMonth(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.month, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/feedin/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of month values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinMonthLastTimeStamp", notes = "get last timestamp of month values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/feedin/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesFeedinMonthLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.month, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/feedin/year
     * save feedin year values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinYear", notes = "save feedin year values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/feedin/year",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesFeedinYear(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.year, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/feedin/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of year values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinYearLastTimeStamp", notes = "get last timestamp of year values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/feedin/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesFeedinYearLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.year, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/production/day
     * save production day values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionDay", notes = "save production day values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/production/day",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesProductionDay(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.day, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of day values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionDayLastTimeStamp", notes = "get last timestamp of day values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/production/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesProductionDayLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.day, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/production/hour
     * save production hour values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionHour", notes = "save production hour values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/production/hour",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesProductionHour(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.hour, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of hour values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionHourLastTimeStamp", notes = "get last timestamp of hour values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/production/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesProductionHourLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.hour, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/production/month
     * save production month values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionMonth", notes = "save production month values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/production/month",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesProductionMonth(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.month, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of month values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionMonthLastTimeStamp", notes = "get last timestamp of month values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/production/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesProductionMonthLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.month, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/production/spontan
     * save production spontan values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionSpontan", notes = "save production spontan values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/production/spontan",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesProductionSpontan(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.spontan, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/spontan/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of spontan values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionSpontanLastTimeStamp", notes = "get last timestamp of spontan values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/production/spontan/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesProductionSpontanLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {
        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.spontan, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/production/year
     * save production year values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionYear", notes = "save production year values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/production/year",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesProductionYear(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.year, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of year values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionYearLastTimeStamp", notes = "get last timestamp of year values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/production/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesProductionYearLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.year, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }

}
