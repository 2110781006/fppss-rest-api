/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (5.0.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.api;

import io.swagger.annotations.*;
import org.openapitools.model.ProviderAccountObject;
import org.openapitools.model.TimeValueObject;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.context.request.NativeWebRequest;

import javax.validation.Valid;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2022-10-01T11:49:21.249468300+02:00[Europe/Vienna]")
@Validated
@Api(value = "values", description = "the values API")
public interface ValuesApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    /**
     * POST /values/consumption/day
     * save consumption day values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionDay", notes = "save consumption day values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/consumption/day",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesConsumptionDay(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.day, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/consumption/day/{userId}/{startdate}/{enddate}
     * get day values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionDayGetDayValues", notes = "get day values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/consumption/day/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesConsumptionDayGetDayValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.day, TimeValueObject.Type.Consumption, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/consumption/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of day values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionDayLastTimeStamp", notes = "get last timestamp of day values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/consumption/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesConsumptionDayLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.day, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/consumption/hour
     * save consumption hour values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionHour", notes = "save consumption hour values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/consumption/hour",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesConsumptionHour(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.hour, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/consumption/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of hour values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionHourLastTimeStamp", notes = "get last timestamp of hour values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/consumption/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesConsumptionHourLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.hour, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/consumption/month
     * save consumption month values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionMonth", notes = "save consumption month values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/consumption/month",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesConsumptionMonth(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.month, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/consumption/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of month values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionMonthLastTimeStamp", notes = "get last timestamp of month values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/consumption/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesConsumptionMonthLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.month, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/consumption/spontan
     * save consumption spontan values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionSpontan", notes = "save consumption spontan values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/consumption/spontan",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesConsumptionSpontan(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.spontan, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/consumption/spontan/{userId}/{startdate}/{enddate}
     * get spontan values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionGetSpontanValues", notes = "get spontan values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/consumption/spontan/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesConsumptionGetSpontanValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.spontan, TimeValueObject.Type.Consumption, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/consumption/spontan/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of spontan values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionSpontanLastTimeStamp", notes = "get last timestamp of spontan values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/consumption/spontan/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesConsumptionSpontanLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.spontan, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/consumption/year
     * save consumption year values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionYear", notes = "save consumption year values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/consumption/year",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesConsumptionYear(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.year, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/consumption/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of year values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionYearLastTimeStamp", notes = "get last timestamp of year values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/consumption/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesConsumptionYearLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.year, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/consumption/hour/{userId}/{startdate}/{enddate}
     * get hour values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionhourGethourValues", notes = "get hour values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/consumption/hour/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesConsumptionhourGethourValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.hour, TimeValueObject.Type.Consumption, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/consumption/month/{userId}/{startdate}/{enddate}
     * get month values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionmonthGetmonthValues", notes = "get month values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/consumption/month/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesConsumptionmonthGetmonthValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.month, TimeValueObject.Type.Consumption, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /values/consumption/year/{userId}/{startdate}/{enddate}
     * get year values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesConsumptionyearGetyearValues", notes = "get year values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/consumption/year/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesConsumptionyearGetyearValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.year, TimeValueObject.Type.Consumption, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }


        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /values/feedin/day
     * save feedin day values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinDay", notes = "save feedin day values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/feedin/day",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesFeedinDay(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.day, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/feedin/day/{userId}/{startdate}/{enddate}
     * get day values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinDayGetDayValues", notes = "get day values of provideraccount and datapointname in time range", response = ProviderAccountObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = ProviderAccountObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/feedin/day/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesFeedinDayGetDayValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.day, TimeValueObject.Type.Feedin, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/feedin/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of day values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinDayLastTimeStamp", notes = "get last timestamp of day values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/feedin/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesFeedinDayLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.day, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/feedin/spontan/{userId}/{startdate}/{enddate}
     * get spontan values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinGetSpontanValues", notes = "get spontan values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/feedin/spontan/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesFeedinGetSpontanValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.spontan, TimeValueObject.Type.Feedin, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/feedin/hour
     * save feedin hour values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinHour", notes = "save feedin hour values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/feedin/hour",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesFeedinHour(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.hour, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/feedin/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of hour values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinHourLastTimeStamp", notes = "get last timestamp of hour values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/feedin/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesFeedinHourLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.hour, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/feedin/month
     * save feedin month values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinMonth", notes = "save feedin month values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/feedin/month",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesFeedinMonth(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.month, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/feedin/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of month values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinMonthLastTimeStamp", notes = "get last timestamp of month values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/feedin/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesFeedinMonthLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.month, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/feedin/spontan
     * save feedin spontan values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinSpontan", notes = "save feedin spontan values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/feedin/spontan",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesFeedinSpontan(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.spontan, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/feedin/spontan/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of spontan values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinSpontanLastTimeStamp", notes = "get last timestamp of spontan values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/feedin/spontan/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesFeedinSpontanLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.spontan, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/feedin/year
     * save feedin year values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinYear", notes = "save feedin year values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/feedin/year",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesFeedinYear(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.year, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);
    }


    /**
     * GET /values/feedin/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of year values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinYearLastTimeStamp", notes = "get last timestamp of year values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/feedin/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesFeedinYearLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.year, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/feedin/hour/{userId}/{startdate}/{enddate}
     * get hour values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinhourGethourValues", notes = "get hour values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/feedin/hour/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesFeedinhourGethourValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.hour, TimeValueObject.Type.Feedin, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/feedin/month/{userId}/{startdate}/{enddate}
     * get month values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinmonthGetmonthValues", notes = "get month values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/feedin/month/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesFeedinmonthGetmonthValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.month, TimeValueObject.Type.Feedin, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * GET /values/feedin/year/{userId}/{startdate}/{enddate}
     * get year values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesFeedinyearGetyearValues", notes = "get year values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/feedin/year/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesFeedinyearGetyearValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.year, TimeValueObject.Type.Feedin, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }


        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }


    /**
     * POST /values/production/day
     * save production day values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionDay", notes = "save production day values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/production/day",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesProductionDay(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.day, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/day/{userId}/{startdate}/{enddate}
     * get day values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionDayGetDayValues", notes = "get day values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/production/day/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesProductionDayGetDayValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.day, TimeValueObject.Type.Production, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of day values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionDayLastTimeStamp", notes = "get last timestamp of day values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/production/day/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesProductionDayLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.day, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/spontan/{userId}/{startdate}/{enddate}
     * get spontan values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionGetSpontanValues", notes = "get spontan values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/production/spontan/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesProductionGetSpontanValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.spontan, TimeValueObject.Type.Production, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/production/hour
     * save production hour values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionHour", notes = "save production hour values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/production/hour",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesProductionHour(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.hour, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of hour values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionHourLastTimeStamp", notes = "get last timestamp of hour values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/production/hour/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesProductionHourLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.hour, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/production/month
     * save production month values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionMonth", notes = "save production month values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/production/month",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesProductionMonth(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.month, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of month values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionMonthLastTimeStamp", notes = "get last timestamp of month values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/production/month/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesProductionMonthLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.month, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/production/spontan
     * save production spontan values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionSpontan", notes = "save production spontan values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/production/spontan",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesProductionSpontan(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.spontan, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/spontan/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of spontan values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionSpontanLastTimeStamp", notes = "get last timestamp of spontan values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/production/spontan/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesProductionSpontanLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {
        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.spontan, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * POST /values/production/year
     * save production year values
     *
     * @param timeValueObject  (required)
     * @return successfully saved (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionYear", notes = "save production year values", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully saved") })
    @PostMapping(
        value = "/values/production/year",
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> valuesProductionYear(@ApiParam(value = "" ,required=true )  @Valid @RequestBody List<TimeValueObject> timeValueObject)
    {
        try
        {
            TimeValueObject.saveInDatabase(TimeValueObject.Resolution.year, timeValueObject);
            return new ResponseEntity<>(HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}
     * get last timestamp of year values of provideraccount and datapointname
     *
     * @param providerAccountId  (required)
     * @param meterId  (required)
     * @param datapointname  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionYearLastTimeStamp", notes = "get last timestamp of year values of provideraccount and datapointname", response = OffsetDateTime.class, tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = OffsetDateTime.class) })
    @GetMapping(
        value = "/values/production/year/lastTimeStamp/{providerAccountId}/{meterId}/{datapointname}",
        produces = { "application/json" }
    )
    default ResponseEntity<OffsetDateTime> valuesProductionYearLastTimeStamp(@ApiParam(value = "",required=true) @PathVariable("providerAccountId") Integer providerAccountId,@ApiParam(value = "",required=true) @PathVariable("meterId") String meterId,@ApiParam(value = "",required=true) @PathVariable("datapointname") String datapointname) {

        try
        {
            return new ResponseEntity<>(TimeValueObject.getLastTimestamp(TimeValueObject.Resolution.year, providerAccountId, meterId, datapointname), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/hour/{userId}/{startdate}/{enddate}
     * get hour values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionhourGethourValues", notes = "get hour values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/production/hour/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesProductionhourGethourValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.hour, TimeValueObject.Type.Production, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return new ResponseEntity<>(HttpStatus.EXPECTATION_FAILED);

    }


    /**
     * GET /values/production/month/{userId}/{startdate}/{enddate}
     * get month values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionmonthGetmonthValues", notes = "get month values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/production/month/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesProductionmonthGetmonthValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.month, TimeValueObject.Type.Production, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }


        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);
    }


    /**
     * GET /values/production/year/{userId}/{startdate}/{enddate}
     * get year values of provideraccount and datapointname in time range
     *
     * @param userId  (required)
     * @param startdate  (required)
     * @param enddate  (required)
     * @return successfully query (status code 200)
     */
    @ApiOperation(value = "", nickname = "valuesProductionyearGetyearValues", notes = "get year values of provideraccount and datapointname in time range", response = TimeValueObject.class, responseContainer = "List", tags={ "values", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "successfully query", response = TimeValueObject.class, responseContainer = "List") })
    @GetMapping(
        value = "/values/production/year/{userId}/{startdate}/{enddate}",
        produces = { "application/json" }
    )
    default ResponseEntity<List<TimeValueObject>> valuesProductionyearGetyearValues(@ApiParam(value = "",required=true) @PathVariable("userId") Integer userId,@ApiParam(value = "",required=true) @PathVariable("startdate") String startdate,@ApiParam(value = "",required=true) @PathVariable("enddate") String enddate) {

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime start = LocalDateTime.parse(startdate, formatter);
            LocalDateTime end = LocalDateTime.parse(enddate, formatter);

            return new ResponseEntity<>(TimeValueObject.readValuesFromDatabase(TimeValueObject.Resolution.year, TimeValueObject.Type.Production, userId, start, end), HttpStatus.OK);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }


        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }

}
